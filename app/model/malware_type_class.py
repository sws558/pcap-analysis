import numpy as np  #四分类模型
import pandas as pd
import tensorflow as tf
from app.extract_tls import preprocess_pcap
from keras.layers import (GRU, Bidirectional, Conv1D, Dense, Input, Lambda,
                          MaxPooling1D, TimeDistributed)
from keras.models import Model
from app import app
from app.model.AttentionNetwork import HierarchicalAttentionNetwork

PACKET_NUM_PER_SESSION = 30
PACKET_LEN = 300
# k_valid_num = 10


def binarize(x, sz=256):
    return tf.cast(tf.one_hot(x, sz, on_value=1, off_value=0, axis=-1), dtype=tf.float32)


def binarize_outshape(in_shape):
    return in_shape[0], in_shape[1], 256


def byte_block(in_layer, nb_filter=(64, 100), filter_length=(3, 3), subsample=(2, 1), pool_length=(2, 2)):
    block = in_layer
    for i in range(len(nb_filter)):
        block = Conv1D(filters=nb_filter[i],
                       kernel_size=filter_length[i],
                       padding='valid',
                       activation='tanh',
                       strides=subsample[i])(block)
        if pool_length[i]:
            block = MaxPooling1D(pool_size=pool_length[i])(block)

    return block


class ModelWang(object):
    def __init__(self, weights_path=None, num_classes=4):
        self.num_classes = num_classes
        if num_classes == 4:
            self.model = self.make_model_malware_type_class()
            # 加载的是load_weights中的权重，检查点是训练的时候用的
            self.model.load_weights(weights_path)
            mode = []
            mode = app.config["MODE_3"]
            self.model.compile(loss=mode[0],
                               optimizer=tf.optimizers.RMSprop(learning_rate=mode[1]), 
                               metrics=mode[2],
                               steps_per_execution = mode[3])
        elif num_classes == 2:
            self.model = self.make_model_normal_malware()
            # 加载的是load_weights中的权重，检查点是训练的时候用的
            self.model.load_weights(weights_path)
            mode = []
            mode = app.config["MODE_4"]
            self.model.compile(loss=mode[0],
                               optimizer=tf.optimizers.RMSprop(learning_rate=mode[1]), 
                               metrics=mode[2],
                               steps_per_execution = mode[3])
        print("succes load")
        print(self.model.summary())

    def read_batch(self, data_raw):
        # data_raw = np_data["data"]  # 多分类
        # data_raw = data_raw.tolist()

        data_arr = []
        for i in range(len(data_raw)):
            data_arr.append(data_raw[i]["data"])

        if len(data_arr) == 0:
            print("read_batch none")
            return None

        pcapdata = np.array(data_arr)
        # print(pcapdata)
        pcapdata = pcapdata[:, :PACKET_NUM_PER_SESSION, :PACKET_LEN] * 255

        pcapdata_reshape = pcapdata.reshape((-1, PACKET_NUM_PER_SESSION, PACKET_LEN))

        return pcapdata_reshape

    def make_model_malware_type_class(self):
        session = Input(shape=(PACKET_NUM_PER_SESSION, PACKET_LEN), dtype='int64')
        input_packet = Input(shape=(PACKET_LEN,), dtype='int64')
        embedded = Lambda(binarize, output_shape=binarize_outshape)(input_packet)
        block = byte_block(embedded, (128, 256), filter_length=(5, 5), subsample=(1, 1), pool_length=(2, 2))
        attn_package = HierarchicalAttentionNetwork(192)(block)
        encoder = Model(inputs=input_packet, outputs=attn_package)
        # encoder.summary()

        review_encoder = TimeDistributed(encoder)(session)
        gru_flow = Bidirectional(GRU(512, return_sequences=True, dropout=0.1, recurrent_dropout=0.1))(review_encoder)
        attn_flow = HierarchicalAttentionNetwork(512)(gru_flow)
        preds = Dense(4, activation='softmax')(attn_flow)
        model = Model(outputs=preds, inputs=session)
        # model.summary()
        return model

    def make_model_normal_malware(self):
        session = Input(shape=(PACKET_NUM_PER_SESSION, PACKET_LEN), dtype='int64')
        input_packet = Input(shape=(PACKET_LEN,), dtype='int64')
        embedded = Lambda(binarize, output_shape=binarize_outshape)(input_packet)
        block = byte_block(embedded, (256, 512), filter_length=(6, 5), subsample=(1, 1), pool_length=(2, 2))
        attn_package = HierarchicalAttentionNetwork(192)(block)
        encoder = Model(inputs=input_packet, outputs=attn_package)
        # encoder.summary()

        review_encoder = TimeDistributed(encoder)(session)
        gru_flow = Bidirectional(GRU(512, return_sequences=True))(review_encoder)
        attn_sentence = HierarchicalAttentionNetwork(512)(gru_flow)
        fullconnect = Dense(512, activation='relu')(attn_sentence)
        fullconnect = Dense(256, activation='relu')(fullconnect)
        preds = Dense(2, activation='softmax')(fullconnect)
        model = Model(outputs=preds, inputs=session)
        # model.summary()
        return model

    def predict(self, pcap_filepath):
        np_data, csv_filepath = preprocess_pcap(pcap_filepath)
        X = self.read_batch(np_data)
        
        if X is None:
            print("predict none")
            # return None
            return pd.DataFrame([])

        predictions = self.model.predict(X)
        predicted_labels = np.argmax(predictions, axis=1)
        predicted_labels = predicted_labels.astype(np.int64)
        # 替换
        predicted_labels = predicted_labels.tolist()
        if self.num_classes == 4:
            for i in range(len(predicted_labels)):
                if predicted_labels[i] == 1:
                    predicted_labels[i] = 'Adware'
                elif predicted_labels[i] == 2:
                    predicted_labels[i] = 'SMSMalware'
                elif predicted_labels[i] == 3:
                    predicted_labels[i] = 'Scareware'
                else:
                    predicted_labels[i] = 'Ransomware'
        elif self.num_classes == 2:
            for i in range(len(predicted_labels)):
                if predicted_labels[i] == 1:
                    predicted_labels[i] = 'VPN'
                else:
                    predicted_labels[i] = 'nonVPN'

        df = pd.read_csv(csv_filepath)
        df["predicted_labels"] = predicted_labels
        return df

    def process_data(self, pcap_filepath):
        np_data, csv_filepath = preprocess_pcap(pcap_filepath)
        X = self.read_batch(np_data)

        if X is None:
            print("predict none")
            return None
        return X


if __name__ == "__main__":
    model_path = app.config["APP_MODEL_DIR"]
    model_HANDLE = ModelWang(
        weights_path="/home/lenovo/opt/pcap_analysis/apps/model/save_model/_300_30_30_malware_type.hdf5")
    flow_df = model_HANDLE.predict(
        "/home/lenovo/opt/pcap_analysis/pcaps/111.pcap")
    print(flow_df)
